### 土曜日

自宅の N150 ミニPC のキャッシュメモリを調べる。
L1, L2, L3 のキャッシュがあり、L1 キャッシュはコア毎に独立していて、
L2, L3 キャッシュはコア間で共有されていた：

```
toyama@blue:~$ lscpu | grep cache
L1d cache:                               128 KiB (4 instances)
L1i cache:                               256 KiB (4 instances)
L2 cache:                                2 MiB (1 instance)
L3 cache:                                6 MiB (1 instance)
```

CPU はキャッシュラインという単位でデータをメモリからキャッシュに読み込む。
弊環境ではL1, L2, L3、ともに 64B だった：

```
toyama@blue:~$ getconf -a | grep CACHE
LEVEL1_ICACHE_SIZE                 65536
LEVEL1_ICACHE_ASSOC                
LEVEL1_ICACHE_LINESIZE             64
LEVEL1_DCACHE_SIZE                 32768
LEVEL1_DCACHE_ASSOC                8
LEVEL1_DCACHE_LINESIZE             64
LEVEL2_CACHE_SIZE                  2097152
LEVEL2_CACHE_ASSOC                 16
LEVEL2_CACHE_LINESIZE              64
LEVEL3_CACHE_SIZE                  6291456
LEVEL3_CACHE_ASSOC                 12
LEVEL3_CACHE_LINESIZE              64
LEVEL4_CACHE_SIZE                  
LEVEL4_CACHE_ASSOC                 
LEVEL4_CACHE_LINESIZE
```

L1キャッシュは CPU コア間で独立していて、キャッシュラインサイズは 64B。


異なるCPUが別々の変数を更新していても、それらの変数が同じキャッシュライン上に存在することで性能が低下する問題（"[False sharing](https://en.wikipedia.org/wiki/False_sharing)"という）があり、その実験をしてみル。

実験コードは以下。２つのCPUが、それぞれのカウンタをインクリメントするだけ：

```c
#include <stdio.h>
#include <stdint.h>
#include <pthread.h>

#define N 1000000000

struct counter {
    uint32_t val;
};

struct counter counters[2];

void *f(void *arg) {
    int id = *(int *)arg;
    for (int i = 0; i < N; i++)
        counters[id].val++;

    return NULL;
}

int main(void) {
    pthread_t t1, t2;
    int id1 = 0;
    int id2 = 1;

    if (pthread_create(&t1, NULL, f, &id1) != 0) {
        fprintf(stderr, "pthread_create() failed\n");
        return 1;
    }
    if (pthread_create(&t2, NULL, f, &id2) != 0) {
        fprintf(stderr, "pthread_create() failed\n");
        return 1;
    }

    if (pthread_join(t1, NULL) != 0) {
        fprintf(stderr, "pthread_join() failed\n");
        return 1;
    }
    if (pthread_join(t2, NULL) != 0) {
        fprintf(stderr, "pthread_join() failed\n");
        return 1;
    }

    printf("counter1=%d, counter2=%d\n", counters[0].val, counters[1].val);

    return 0;
}
```

`counters[0]` と `counters[1]` は構造体の隣り合わせに配置されるため、
同じキャッシュラインに入ってしまう可能性が高い。

比較対象として、構造体にパディングを追加して L1 キャッシュで共有されないようにするコードを用意する。diff は1行：

```diff
$ diff -u test-false-sharing-no-padding.c test-false-sharing-padding.c 
--- test-false-sharing-no-padding.c	2025-10-04 20:37:08.696907085 +0900
+++ test-false-sharing-padding.c	2025-10-04 20:36:56.627786082 +0900
@@ -6,6 +6,7 @@
 
 struct counter {
     uint32_t val;
+    uint8_t padding[64];
 };
 
 struct counter counters[2];
```

結果は以下：

- パディングなし：

    ```
    toyama@blue:~$ time ./test-no-padding 
    counter1=1000000000, counter2=1000000000

    real	0m4.594s
    user	0m8.734s
    sys	0m0.006s
    ```

- パディングあり：

    ```
    toyama@blue:~$ time ./test-padding 
    counter1=1000000000, counter2=1000000000

    real	0m1.323s
    user	0m2.628s
    sys	0m0.002s
    ```

パディングありは、なしと比べて約3.47倍速かった。
False sharing は思ったよりも性能が悪くなるんだな。
（ちなみに、real より user が大きいのは、CPU が並列で動いているため）。
こういう実験が気軽にできるのは、実機 Linux PC の良さだよな。うれしい。

そういえば、Rui さんの mold リンカの並行ハッシュマップでも False sharing を避けるような最適化を入れた[話をされていたな](https://www.youtube.com/live/_LQ6jvB7sq8?si=QsvBCuU2_DDNDHCk&t=805)。

---

https://x.com/Yuk3u/status/1973771479398617476

確かに。 ミニPCを確認したら 423 MBだった。
ほとんど何もタスクをしてないとはいえ、システム全体で 423MB ってすごいな。
mac で開いてる Chrome のタブ１つがそれぐらいだった。Chrome さん使いすぎでは？

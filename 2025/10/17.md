### proposal: time: optimize algorithms by restricting valid year range

https://github.com/golang/go/issues/63844

Normandes Junior の提案は以下：

* Neri-Schneider アルゴリズムを使いたい。
    * このアルゴリズムは、時間や日付の計算を高速化するもの。
    * 時間や日付の計算には、割り算やその余りの計算が大量に出てくる。
    * 割り算や余りは普通にCPUで計算すると遅い。（掛け算が1\~7サイクル、割り算が10\~40サイクルほど。参照：http://ithare.com/infographics-operation-costs-in-cpu-clock-cycles/）
    * なので、割り算を、定数掛け算 + ビットシフトに置き換える (Strength reduction) が提案された (Granlund & Montgomery ら）。
    * Neri-Schneider はその一般化？
* Golang で date 型の year, month, hour で取りうる有効な値を狭めたい。
    * Neri-Schneider アルゴリズムを使用するため？
* Time パッケージの仕様として、サポートされる日付の範囲を明示すべき
    * 現状では int 型。なのでmath.MinInt から math.MaxInt まで受け取ってしまう。

Go言語がサポートする日時の範囲を狭めたいという提案は Neri-Schneider アルゴリズムを使うためだけ、でもないらしい。
地球の自転は遅くなっている（今は1年に365回転だが、恐竜の時代は約400回転）ため、
今日採用されているグレゴリオ暦を基準に、
たとえば 1年1月1日を -65,000,000年と呼ぶのはナンセンスだよね、とのこと：

> (*) It's worth mentioning that the Gregorian calendar is still not perfectly aligned to Earth's motions and a small error is accumulating. In a few thousands of years the error should be quite noticeable. Furthermore, Earth's rotation is slowing down which amplifies the problem [9]. The point here is that it's virtually impossible for the Gregorian calendar to remain in use in the next few thousands of years, let alone in billions of years.

サポートする日付の範囲を狭めることに対する Russ Cox の[反論](https://github.com/golang/go/issues/63844#issuecomment-2117539025)。
既に書かれた Go ソースコードの中には、
`var forever = time.Date(100000, January 1, 0, 0, 0, time.UTC)` のように sentinel の日付として書かれたものもあるため、
それらが動かなくなるのはまずいとのこと。

そのように鋭く反論した Russ Cox さん。Neri-Schneider のアルゴリズムを使いつつも、サポートする日付の範囲は狭めないパッチを[自力で作っていた](https://github.com/golang/go/commit/c5de95076669ad2416aeec941912af723f2ccf78)。
かっこ良すぎる：

> Proposal #63844 suggested adopting this algorithm and simultaneously
> restricting the range of valid years supported by the package from its
> current ±292277022399 (plenty for anyone) to a mere ±32767.
> This CL does NOT make any such restriction. The range of valid years
> is almost exactly what it was before. 

### Computational calendar

日付、時間に関する標準ライブラリを見ていると、
普通のカレンダーとは違う、Computational calendar というものが出てくる。
例えば Linux の例は以下：

https://github.com/torvalds/linux/blob/master/kernel/time/timeconv.c#L78

Computational calendar は年の始まりを3月1日、年の終わりを翌年の2月末とする。
この、「うるう年を年末側に追いやる」工夫をすることで、うるう年の計算処理がシンプルになる、という理解。
１年間の日数を計算したり、特定の日付がその年の何日目かを計算したりするときに、普通のカレンダーだと一年の初めの方からうるう年を気にする必要がある。
Computational calendar を導入することで、１年間のどの時点でも、うるう年の影響を受けるのは最後の日だけなので、計算ロジックがシンプルになる。
### 火曜日

[moldの並行ハッシュマップの最適化](https://www.youtube.com/watch?v=_LQ6jvB7sq8)。
マルチコアCPU環境において、
CPUキャッシュラインに起因する false sharing を緩和するためのデータ構造の最適化、という話。
この最適化により、リンカの文字列をマージする工程が 10%~15% ほど性能が向上したとのこと。
[該当コミット](https://github.com/rui314/mold/commit/1a13c5076e7e3f6528a6f98201e6b2f73ccde243)。

#### リンカにおけるハッシュマップ

リンカとは、複数のオブジェクトファイルから１つの実行ファイルを作るソフトウェア。
リンカの工程の１つに文字列のマージがある。
文字列のマージとは、複数の同じ文字列を１つにまとめること。
文字列のマージにより、複数のオブジェクトファイルに存在する同じ文字列を、実行ファイルに１つ埋め込むだけでいいので、実行ファイルのサイズの節約になる。

mold リンカでは文字列のマージにハッシュマップを使用する。
特に複数のCPUコアがハッシュマップを操作する並行ハッシュマップを使用する。

#### CPU キャッシュライン

CPUキャッシュラインとは、CPUがメインメモリからデータを読み書きする際の最小単位のこと。

たとえば自分の M2 MacBook Air は 128 バイトだった：

```
tym@:~ $ sysctl -a | grep cacheline 
hw.cachelinesize: 128
```

#### False sharing

[False sharing](https://en.wikipedia.org/wiki/False_sharing) とは、マルチコアCPU環境において、複数のCPUコアが、それぞれ異なるデータを扱っているにもかかわらず、それらのデータがたまたま同じキャッシュライン上に存在するために発生するパフォーマンス低下の問題。

mold の修正前の実装では、
ハッシュマップのキーに文字列へのポインタを使用し、
キー全体はポインタの配列で表していた。
64bit環境だとポインタは８バイト。
キャッシュラインが64バイトと仮定すると、
１つのキャッシュラインに８つのキーが存在する。
ハッシュマップは複数のCPUコアからアクセスされるため、
False sharing が起こりうる。

修正後は、ハッシュマップのデータ構造を変え、
１つのエントリが[32バイトアラインされる](https://github.com/rui314/mold/commit/1a13c5076e7e3f6528a6f98201e6b2f73ccde243#diff-34c932128256ee886b3a8581b5f11a1c38717aaa9d228189f1ce12e823f3207fR487)ようになった。
そのため、１つのキャッシュライン（64バイトと仮定）に載るエントリ数が２となり、False sharing が緩和された。
